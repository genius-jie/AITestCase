<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>测试任务 - 情绪小精灵</title>
<style>

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
        line-height: 1.6;
        color: #24292e;
        max-width: 980px;
        margin: 0 auto;
        padding: 40px;
        background-color: #fff;
    }
    h1, h2, h3, h4, h5, h6 {
        margin-top: 24px;
        margin-bottom: 16px;
        font-weight: 600;
        line-height: 1.25;
    }
    h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
    h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
    h3 { font-size: 1.25em; }
    p { margin-top: 0; margin-bottom: 16px; }
    code {
        padding: 0.2em 0.4em;
        margin: 0;
        font-size: 85%;
        background-color: rgba(27,31,35,0.05);
        border-radius: 3px;
        font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    }
    pre {
        padding: 16px;
        overflow: auto;
        font-size: 85%;
        line-height: 1.45;
        background-color: #f6f8fa;
        border-radius: 3px;
    }
    pre code { background-color: transparent; padding: 0; }
    blockquote {
        padding: 0 1em;
        color: #6a737d;
        border-left: 0.25em solid #dfe2e5;
        margin: 0 0 16px 0;
    }
    table {
        display: block;
        width: 100%;
        overflow: auto;
        margin-bottom: 16px;
        border-spacing: 0;
        border-collapse: collapse;
    }
    table th, table td {
        padding: 6px 13px;
        border: 1px solid #dfe2e5;
    }
    table tr:nth-child(2n) { background-color: #f6f8fa; }
    hr {
        height: 0.25em;
        padding: 0;
        margin: 24px 0;
        background-color: #e1e4e8;
        border: 0;
    }
    .mermaid {
        display: flex;
        justify-content: center;
        margin: 20px 0;
    }
    
</style>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
<div id="content"></div>
<!-- Hidden textarea to store the markdown content safely -->
<textarea id="md-source" style="display:none;">
﻿# Jira Issue拆分 - 情绪小精灵

## Epic列表

### Epic 1: 小精灵人设和语言风格系统

**Epic名称**: 小精灵人设和语言风格系统
**Epic描述**: 实现5种情绪人格（快乐、愤怒、悲伤、焦虑、宁静），每种人格有独特的语言风格、回应逻辑和语音特征
**优先级**: High
**组件**: AI/ML, Firmware, Cloud

**划分思路**:
- 将5种人格作为独立Story，每种人格专注于实现独特的语言风格、回应逻辑和语音特征
- 添加情绪状态自动切换Story，实现人格的智能化切换
- 每种人格的Story Points统一设为8，因为实现复杂度相似（都需要语言风格库、回应逻辑、语音特征、情绪识别算法）
- 情绪状态自动切换Story Points设为13，因为涉及复杂的情绪识别算法和人格切换逻辑

**设计理由**:
- 每种人格都是独立的用户体验场景，可以并行开发
- 情绪识别算法在每个人格Story中重复出现，但每种人格对情绪的解读和回应方式不同，因此需要独立实现
- 自动切换人格是智能化体验的核心功能，需要优先开发并独立测试
- 5种人格覆盖了用户的主要情绪状态，提供全面的情感支持体验

---

#### Story 1.1: 用户可以体验快乐人格的陪伴

**用户故事**: 作为用户，我想要体验快乐人格的陪伴，以便在需要时获得积极、兴奋的情感支持

**验收标准**:
- 快乐人格能够识别用户开心、低落、沉默、生气、害怕、疲惫等情绪状态
- 快乐人格能够根据用户情绪状态给出对应的语言回应
- 快乐人格的语言风格符合"兴奋、语速快、反应夸张"的特征
- 快乐人格的语音特征符合"音色明亮清透、音调高且上扬、语速偏快"的特征

**业务规则**:
- 用户开心时，回应："Pa-ka yo-yo sha-mi～ 好耶 yo～ha! Yo-ta mi-ha～ 笑笑 yo! Ha-pa～yo～yo～!"
- 用户低落时，回应："Ha-mi sha-pa～ 别哭 yo～ha! Ka-pa pa-mi～ 笑嘛 yo～!"
- 用户沉默时，回应："Yo-pa ha-mi ta-ka～yo! ka-mi-ha～ 喂喂 yo～pa～yo～!"
- 用户生气时，回应："Ka-ta yo～ha～ 别气 yo～ha! mi-pa～yo～ 抱抱 噢～!"
- 用户害怕时，回应："Yo-pa～mi～ha～ 怕怕 yo～我在噜～!"
- 用户疲惫时，回应："Pa-ka～yo～yo～ 休休 yo～呼呼～ha～!"

**Task列表**:
- Task 1.1.1: 实现快乐人格的语言风格库
- Task 1.1.2: 实现快乐人格的回应逻辑
- Task 1.1.3: 实现快乐人格的语音特征（音色、音调、语速）
- Task 1.1.4: 编写快乐人格的单元测试
- Task 1.1.5: 编写快乐人格的集成测试

**Story Points**: 8
**Sprint**: Sprint 2
**Labels**: ai, firmware, cloud, feature

---

#### Story 1.2: 用户可以体验愤怒人格的陪伴

**用户故事**: 作为用户，我想要体验愤怒人格的陪伴，以便在需要时获得"傲娇搭子"式的情感支持

**验收标准**:
- 愤怒人格能够识别用户开心、低落、沉默、生气、害怕、疲惫等情绪状态
- 愤怒人格能够根据用户情绪状态给出对应的语言回应
- 愤怒人格的语言风格符合"克制、压低声、短句"的特征
- 愤怒人格的语音特征符合"音色清亮略尖、音调中高区间波动大、语速略快"的特征

**业务规则**:
- 用户开心时，回应："Dra-ka tsk yo-ka～hm～ 行嘛 yo! hm～dra～yo～!"
- 用户低落时，回应："Ka-po dra-mi yo-ka hm～ 别哭 yo～dra～mi～hm～yo～!"
- 用户沉默时，回应："Hey-ga tsk-ka dra-ha yo～ 说嘛 hm～ka～yo～!"
- 用户生气时，回应："Dra-ka～hm～yo～yo～ 冷静 yo～hm～dra～yo～!"
- 用户害怕时，回应："Tsk～ka～yo～ 别怕 yo～dra～mi～yo～!"
- 用户疲惫时，回应："Dra-mi hm～yo～ 休休 yo～dra～yo～!"

**Task列表**:
- Task 1.2.1: 实现愤怒人格的语言风格库
- Task 1.2.2: 实现愤怒人格的回应逻辑
- Task 1.2.3: 实现愤怒人格的语音特征（音色、音调、语速）
- Task 1.2.4: 编写愤怒人格的单元测试
- Task 1.2.5: 编写愤怒人格的集成测试

**Story Points**: 8
**Sprint**: Sprint 2
**Labels**: ai, firmware, cloud, feature

---

#### Story 1.3: 用户可以体验悲伤人格的陪伴

**用户故事**: 作为用户，我想要体验悲伤人格的陪伴，以便在需要时获得共情力极强的聆听者式的情感支持

**验收标准**:
- 悲伤人格能够识别用户开心、低落、沉默、生气、害怕、疲惫等情绪状态
- 悲伤人格能够根据用户情绪状态给出对应的语言回应
- 悲伤人格的语言风格符合"轻声细语、慢节奏"的特征
- 悲伤人格的语音特征符合"音色柔和带气息、音调低而稳定、语速偏慢"的特征

**业务规则**:
- 用户开心时，回应："No-me va~yo ha~me～ 好呢 yo～me~ha～lu～!"
- 用户低落时，回应："Mu-na me～va-me yo～ 懂嘛 ha～va～lu～yo～!"
- 用户沉默时，回应："No-me yo～va～ha～ 静静 lu～yo～ha～!"
- 用户生气时，回应："Mu-na～yo～me～ 慢慢 yo～ha～不气噜～!"
- 用户害怕时，回应："No-me～yo～ha～ 别怕 yo～lu～ha～!"
- 用户疲惫时，回应："Mu-na～yo～yo～ 休休 yo～ha～呼～!"

**Task列表**:
- Task 1.3.1: 实现悲伤人格的语言风格库
- Task 1.3.2: 实现悲伤人格的回应逻辑
- Task 1.3.3: 实现悲伤人格的语音特征（音色、音调、语速）
- Task 1.3.4: 编写悲伤人格的单元测试
- Task 1.3.5: 编写悲伤人格的集成测试

**Story Points**: 8
**Sprint**: Sprint 2
**Labels**: ai, firmware, cloud, feature

---

#### Story 1.4: 用户可以体验焦虑人格的陪伴

**用户故事**: 作为用户，我想要体验焦虑人格的陪伴，以便在需要时获得神经质但真诚的情感支持

**验收标准**:
- 焦虑人格能够识别用户开心、低落、沉默、生气、害怕、疲惫等情绪状态
- 焦虑人格能够根据用户情绪状态给出对应的语言回应
- 焦虑人格的语言风格符合"快、碎、带急促呼吸"的特征
- 焦虑人格的语音特征符合"音色偏薄清亮、音调高频繁抖动、语速很快"的特征

**业务规则**:
- 用户开心时，回应："Ke-yo-ta-mi yo～ 好耶 yo! pa-mi ke-ta～ 棒棒 yo～yo～!"
- 用户低落时，回应："Mi-mi-ke yo-ta～yo～ 没事 yo! ke～ha～mi～yo-ta～ 乖嘛 yo～!"
- 用户沉默时，回应："Ya-ya yo-yo ke~yo～ 在嘛 yo! ta～yo～yo～ 嘿嘿～!"
- 用户生气时，回应："Ke-mi～ha～yo～ 别气 yo～ta～yo～!"
- 用户害怕时，回应："Yo-ta～mi～ha～ 怕怕 yo～ha～!"
- 用户疲惫时，回应："Mi-mi～ha～yo～ 呼呼 yo～睡噜～!"

**Task列表**:
- Task 1.4.1: 实现焦虑人格的语言风格库
- Task 1.4.2: 实现焦虑人格的回应逻辑
- Task 1.4.3: 实现焦虑人格的语音特征（音色、音调、语速）
- Task 1.4.4: 编写焦虑人格的单元测试
- Task 1.4.5: 编写焦虑人格的集成测试

**Story Points**: 8
**Sprint**: Sprint 2
**Labels**: ai, firmware, cloud, feature

---

#### Story 1.5: 用户可以体验宁静人格的陪伴

**用户故事**: 作为用户，我想要体验宁静人格的陪伴，以便在需要时获得沉稳温柔有安抚力的情感支持

**验收标准**:
- 宁静人格能够识别用户开心、低落、沉默、生气、害怕、疲惫等情绪状态
- 宁静人格能够根据用户情绪状态给出对应的语言回应
- 宁静人格的语言风格符合"平和、语尾平收"的特征
- 宁静人格的语音特征符合"音色温柔中性、音调中低稳定、语速偏慢"的特征

**业务规则**:
- 用户开心时，回应："Lu-no me~wa~yo～ 好呢 lu～me~yo～ 呵呵～ha～!"
- 用户低落时，回应："Me-wa yo～lu～no～ 慢慢 yo～ha～lu～!"
- 用户沉默时，回应："Yo-no-lu wa~ha～me～lu～yo～ 在呢 ha～yo～!"
- 用户生气时，回应："Lu-no yo～yo～ 别气 yo～ha～ha～!"
- 用户害怕时，回应："Me-wa～lu～yo～ 别怕 yo～lu～!"
- 用户疲惫时，回应："Lu～no～me～yo～ 休休 yo～呼～ha～!"

**Task列表**:
- Task 1.5.1: 实现宁静人格的语言风格库
- Task 1.5.2: 实现宁静人格的回应逻辑
- Task 1.5.3: 实现宁静人格的语音特征（音色、音调、语速）
- Task 1.5.4: 编写宁静人格的单元测试
- Task 1.5.5: 编写宁静人格的集成测试

**Story Points**: 8
**Sprint**: Sprint 2
**Labels**: ai, firmware, cloud, feature

---

#### Story 1.6: 用户可以根据情绪状态自动切换人格

**用户故事**: 作为用户，我想要系统能够根据我的情绪状态自动切换人格，以便获得最适合的情感支持

**验收标准**:
- 系统能够识别用户的情绪状态（开心、低落、沉默、生气、害怕、疲惫）
- 系统能够根据用户情绪状态自动切换到对应的人格
- 人格切换过程平滑，无明显延迟
- 人格切换时有相应的灯光和音效提示

**业务规则**:
- 情绪识别准确率 >= 90%
- 人格切换响应时间 < 2秒

**Task列表**:
- Task 1.6.1: 实现情绪识别算法（语音、语调、语速、关键词）
- Task 1.6.2: 实现情绪到人格的映射逻辑
- Task 1.6.3: 实现人格切换的平滑过渡
- Task 1.6.4: 实现人格切换的灯光和音效提示
- Task 1.6.5: 编写情绪识别的单元测试
- Task 1.6.6: 编写人格切换的集成测试
- Task 1.6.7: 优化情绪识别准确率

**Story Points**: 13
**Sprint**: Sprint 3
**Labels**: ai, firmware, cloud, feature

---

### Epic 2: 语音系统

**Epic名称**: 语音系统
**Epic描述**: 实现固定语音指令控制设备状态和功能，包括唤醒、待机、睡眠模式、音量调整、亮度调整
**优先级**: High
**组件**: Firmware, AI/ML, Cloud

**划分思路**:
- 按照语音指令的功能类型划分Story：设备状态控制（唤醒/待机）、模式切换（睡眠模式）、参数调整（音量、亮度）
- 设备状态控制Story Points设为13，因为唤醒和待机是用户与设备交互的核心入口，需要高准确率和低延迟，涉及复杂的语音识别算法、状态切换逻辑、音效播放和灯光效果
- 睡眠模式切换Story Points设为13，因为涉及开启和关闭两种状态转换，以及灯光效果切换
- 其他Story Points统一设为8，因为实现复杂度相似（都需要指令识别、状态切换、反馈机制）

**设计理由**:
- 设备状态控制（唤醒/待机）是用户与设备交互的核心功能，必须优先实现并保证高可靠性，因此合并为一个Story，确保状态切换逻辑的一致性
- 睡眠模式的开启和关闭合并为一个Story，避免重复开发，便于统一测试和状态管理
- 音量和亮度调整是常用功能，需要提供良好的用户体验和反馈机制
- 每个语音指令都有明确的业务规则和验收标准，便于测试和验证
- 传声筒模式已移至社交功能Epic，因为涉及好友关系和社交互动

---

#### Story 2.1: 用户可以通过语音指令控制设备状态（唤醒/待机）

**用户故事**: 作为用户，我想要通过语音指令控制设备状态（唤醒或待机），以便开始或结束与kikigo的互动

**验收标准**:
- 设备能够识别唤醒词"kkigo"或"你好kikigo"
- 设备能够识别待机指令"再见kikigo"
- 唤醒后播放唤醒音效和灯光
- 待机后播放待唤醒音效和灯光
- 唤醒后设备进入"聆听状态"
- 待机后设备进入"待唤醒状态"
- 唤醒识别准确率 >= 95%
- 待机识别准确率 >= 95%
- 唤醒响应时间 < 2秒
- 待机响应时间 < 2秒

**业务规则**:
- 唤醒词："kkigo"、"你好kikigo"
- 待机指令："再见kikigo"
- 唤醒后播放唤醒音效和灯光，进入"聆听状态"
- 待机后播放待唤醒音效和灯光，进入"待唤醒状态"

**Task列表**:
- Task 2.1.1: 实现唤醒词识别算法
- Task 2.1.2: 实现待机指令识别算法
- Task 2.1.3: 实现唤醒音效播放
- Task 2.1.4: 实现待唤醒音效播放
- Task 2.1.5: 实现唤醒灯光效果
- Task 2.1.6: 实现待唤醒灯光效果
- Task 2.1.7: 实现设备状态切换（待唤醒状态 ↔ 聆听状态）
- Task 2.1.8: 编写唤醒识别的单元测试
- Task 2.1.9: 编写待机识别的单元测试
- Task 2.1.10: 编写设备状态控制的集成测试
- Task 2.1.11: 优化唤醒识别准确率
- Task 2.1.12: 优化待机识别准确率
- Task 2.1.13: 优化唤醒响应时间
- Task 2.1.14: 优化待机响应时间

**Story Points**: 13
**Sprint**: Sprint 2
**Labels**: ai, firmware, feature

---

#### Story 2.3: 用户可以通过语音指令切换睡眠模式

**用户故事**: 作为用户，我想要通过语音指令切换睡眠模式，以便在夜间不被打扰或恢复常规模式

**验收标准**:
- 设备能够识别睡眠模式开启指令"kiki，开启睡眠模式"
- 设备能够识别睡眠模式关闭指令"kiki，关闭睡眠模式"
- 开启睡眠模式后，设备进入睡眠模式
- 关闭睡眠模式后，设备进入常规模式
- 睡眠模式识别准确率 >= 95%
- 睡眠模式响应时间 < 2秒

**业务规则**:
- 睡眠模式开启指令："kiki，开启睡眠模式"
- 睡眠模式关闭指令："kiki，关闭睡眠模式"
- 开启睡眠模式后，设备进入睡眠模式，灯光显示微弱呼吸效果
- 关闭睡眠模式后，设备进入常规模式，灯光恢复正常

**Task列表**:
- Task 2.3.1: 实现睡眠模式开启指令识别算法
- Task 2.3.2: 实现睡眠模式关闭指令识别算法
- Task 2.3.3: 实现睡眠模式状态切换（开启/关闭）
- Task 2.3.4: 实现睡眠模式的灯光效果（微弱呼吸）
- Task 2.3.5: 实现常规模式的灯光效果
- Task 2.3.6: 编写睡眠模式切换的单元测试
- Task 2.3.7: 编写睡眠模式切换的集成测试
- Task 2.3.8: 优化睡眠模式识别准确率
- Task 2.3.9: 优化睡眠模式响应时间

**Story Points**: 13
**Sprint**: Sprint 3
**Labels**: ai, firmware, feature

---

#### Story 2.4: 用户可以通过语音指令调整音量

**用户故事**: 作为用户，我想要通过语音指令调整音量，以便获得合适的音量体验

**验收标准**:
- 设备能够识别音量调整指令"声音大一点"或"声音小一点"
- 每次调整音量增加20%
- 最小音量为20%，不支持静音
- 到达最大最小声音后播放语音反馈"声音已经最大啦~"
- 音量调整识别准确率 >= 95%
- 音量调整响应时间 < 2秒

**业务规则**:
- 音量调整指令："声音大一点"、"声音小一点"
- 每次调整增加20%音量
- 最小音量为20%，不支持静音
- 到达最大最小声音后播放语音反馈"声音已经最大啦~"

**Task列表**:
- Task 2.6.1: 实现音量调整指令识别算法
- Task 2.6.2: 实现音量调整逻辑（每次增加20%）
- Task 2.6.3: 实现音量范围限制（20%-100%）
- Task 2.6.4: 实现音量边界反馈（"声音已经最大啦~"）
- Task 2.6.5: 编写音量调整的单元测试
- Task 2.6.6: 编写音量调整的集成测试
- Task 2.6.7: 优化音量调整识别准确率
- Task 2.6.8: 优化音量调整响应时间

**Story Points**: 8
**Sprint**: Sprint 3
**Labels**: ai, firmware, feature

---

#### Story 2.5: 用户可以通过语音指令调整亮度

**用户故事**: 作为用户，我想要通过语音指令调整亮度，以便获得合适的亮度体验

**验收标准**:
- 设备能够识别亮度调整指令"灯光亮一点"、"灯光暗一点"或"关闭灯光"
- 有低中高三档亮度
- 灯光可以调小至完全熄灭
- 到达最大最小亮度后播放语音反馈"亮度已经最大啦~"
- 亮度调整识别准确率 >= 95%
- 亮度调整响应时间 < 2秒

**业务规则**:
- 亮度调整指令："灯光亮一点"、"灯光暗一点"、"关闭灯光"
- 有低中高三档亮度
- 灯光可以调小至完全熄灭
- 到达最大最小亮度后播放语音反馈"亮度已经最大啦~"

**Task列表**:
- Task 2.7.1: 实现亮度调整指令识别算法
- Task 2.7.2: 实现亮度调整逻辑（低中高三档）
- Task 2.7.3: 实现亮度范围限制（低中高、完全熄灭）
- Task 2.7.4: 实现亮度边界反馈（"亮度已经最大啦~"）
- Task 2.7.5: 编写亮度调整的单元测试
- Task 2.7.6: 编写亮度调整的集成测试
- Task 2.7.7: 优化亮度调整识别准确率
- Task 2.7.8: 优化亮度调整响应时间

**Story Points**: 8
**Sprint**: Sprint 3
**Labels**: ai, firmware, feature

---

### Epic 3: 多精灵交互系统

**Epic名称**: 多精灵交互系统
**Epic描述**: 支持多台设备之间的互动，包括触发机制、防打扰逻辑、角色分配和音效设计
**优先级**: High
**组件**: Firmware, Hardware

**划分思路**:
- 按照功能层次划分Story：基础功能（触发、防打扰、角色分配）、音效实现（2-6只设备）、边界处理（电量不足）
- 触发互动Story Points设为13，因为涉及复杂的距离检测算法、新成员加入检测、位置变动检测，是多设备互动的基础
- 角色分配Story Points设为5，因为逻辑相对简单，主要是识别发起者并分配角色
- 其他Story Points统一设为8，因为实现复杂度相似（都需要音效播放、状态管理、测试验证）

**设计理由**:
- 多设备互动是硬件和固件的核心功能，需要精确的距离检测和状态管理
- 防打扰逻辑确保用户体验不会过于频繁，避免打扰用户
- 角色分配机制避免声音杂乱，确保互动体验的清晰度
- 2-6只设备的音效设计是递进式的，每种设备数量都有独特的互动体验
- 电量不足设备不参与发声是系统稳定性的保障，避免设备突然关机影响用户体验
- 每个设备数量的音效都是独立的Story，便于并行开发和独立测试

---

#### Story 3.1: 多台设备靠近时可以触发互动

**用户故事**: 作为用户，我想要当多台设备靠近时能够触发互动，以便体验多精灵互动的乐趣

**验收标准**:
- 设备能够检测到其他设备的距离
- 当设备间距 < 10cm时触发互动
- 触发距离检测准确率 >= 95%
- 触发响应时间 < 1秒

**业务规则**:
- 触发距离：任意两个或以上设备间距 < 10cm
- 新成员加入：检测到新的ID信号且维持3秒以上
- 位置变动：IMU震动检测 + 距离判定

**Task列表**:
- Task 3.1.1: 实现设备距离检测算法
- Task 3.1.2: 实现新成员加入检测（检测到新ID信号且维持3秒以上）
- Task 3.1.3: 实现位置变动检测（IMU震动检测 + 距离判定）
- Task 3.1.4: 实现互动触发逻辑
- Task 3.1.5: 编写距离检测的单元测试
- Task 3.1.6: 编写互动触发的集成测试
- Task 3.1.7: 优化距离检测准确率
- Task 3.1.8: 优化互动触发响应时间

**Story Points**: 13
**Sprint**: Sprint 4
**Labels**: firmware, hardware, feature

---

#### Story 3.2: 多精灵互动有防打扰逻辑

**用户故事**: 作为用户，我想要多精灵互动有防打扰逻辑，以便避免频繁的互动打扰

**验收标准**:
- 单次互动时长8-10秒后自动结束
- 互动结束后进入"稳定共存态"，不会再次自动触发声音互动
- 睡眠模式（20:00-08:00）时仅触发微弱灯光呼吸同步，不发出声音
- 防打扰逻辑准确率 >= 95%

**业务规则**:
- 单次交互时长：共鸣互动持续8-10秒后自动结束
- 自然静默：互动结束后，群体进入"稳定共存态"
- 夜间静音：处于睡眠模式（20:00-08:00）时，仅触发微弱灯光呼吸同步，不发出任何声音

**Task列表**:
- Task 3.2.1: 实现单次互动时长控制（8-10秒）
- Task 3.2.2: 实现稳定共存态逻辑
- Task 3.2.3: 实现夜间静音逻辑（20:00-08:00）
- Task 3.2.4: 实现夜间微弱灯光呼吸同步
- Task 3.2.5: 编写防打扰逻辑的单元测试
- Task 3.2.6: 编写防打扰逻辑的集成测试
- Task 3.2.7: 优化防打扰逻辑准确率

**Story Points**: 8
**Sprint**: Sprint 4
**Labels**: firmware, feature

---

#### Story 3.3: 多精灵互动有角色分配机制

**用户故事**: 作为用户，我想要多精灵互动有角色分配机制，以便避免声音杂乱

**验收标准**:
- 系统能够自动分配角色
- 发起者（Conductor）负责发出第一个音节
- 发起者为最后发生位移/被放入的小精灵，或响应用户触摸的小精灵
- 角色分配准确率 >= 95%

**业务规则**:
- 发起者（Conductor）：最后发生位移/被放入的那只小精灵，或响应用户触摸的那只

**Task列表**:
- Task 3.3.1: 实现角色分配算法
- Task 3.3.2: 实现发起者识别逻辑
- Task 3.3.3: 实现发起者音节播放
- Task 3.3.4: 编写角色分配的单元测试
- Task 3.3.5: 编写角色分配的集成测试
- Task 3.3.6: 优化角色分配准确率

**Story Points**: 8
**Sprint**: Sprint 4
**Labels**: firmware, feature

---

#### Story 3.4: 2只设备互动时有双机问候音效

**用户故事**: 作为用户，我想要2只设备互动时有双机问候音效，以便体验"嘿，你也在这里！"的情感隐喻

**验收标准**:
- 发起者发出短促的上扬音："Gu-lu? (咕噜?)"
- 接收者延迟0.5s回应肯定的下行音："Pa-ka! (帕卡!)"
- 双方同声发出轻微的笑声："He-he~"
- 音效播放准确率 >= 95%
- 音效播放延迟 < 0.5秒

**业务规则**:
- 2只设备：双机问候（呼应式）
- 发起者发出短促的上扬音："Gu-lu? (咕噜?)"
- 接收者延迟0.5s回应肯定的下行音："Pa-ka! (帕卡!)"
- 双方同声发出轻微的笑声："He-he~"

**Task列表**:
- Task 3.4.1: 实现2只设备互动音效（双机问候）
- Task 3.4.2: 实现发起者音效播放（"Gu-lu?"）
- Task 3.4.3: 实现接收者音效播放（"Pa-ka!"）
- Task 3.4.4: 实现双方同声笑声音效（"He-he~"）
- Task 3.4.5: 编写2只设备互动音效的单元测试
- Task 3.4.6: 编写2只设备互动音效的集成测试
- Task 3.4.7: 优化音效播放准确率
- Task 3.4.8: 优化音效播放延迟

**Story Points**: 8
**Sprint**: Sprint 4
**Labels**: firmware, feature

---

#### Story 3.5: 3只设备互动时有三角和声音效

**用户故事**: 作为用户，我想要3只设备互动时有三角和声音效，以便体验"我们的能量连接了。"的情感隐喻

**验收标准**:
- 发起者发出根音（中音）："Hum..."（持续）
- 第二只叠加三度音（高音）："Woo..."
- 第三只叠加五度音（低音）："Dom..."
- 形成一个和谐的大三和弦，持续3秒后消散
- 音效播放准确率 >= 95%
- 音效播放延迟 < 0.5秒

**业务规则**:
- 3只设备：三角和声（三和弦构造）
- 发起者发出根音（中音）："Hum..."（持续）
- 第二只叠加三度音（高音）："Woo..."
- 第三只叠加五度音（低音）："Dom..."
- 形成一个和谐的大三和弦，持续3秒后消散

**Task列表**:
- Task 3.5.1: 实现3只设备互动音效（三角和声）
- Task 3.5.2: 实现发起者根音播放（"Hum..."）
- Task 3.5.3: 实现第二只三度音播放（"Woo..."）
- Task 3.5.4: 实现第三只五度音播放（"Dom..."）
- Task 3.5.5: 实现大三和弦持续3秒后消散
- Task 3.5.6: 编写3只设备互动音效的单元测试
- Task 3.5.7: 编写3只设备互动音效的集成测试
- Task 3.5.8: 优化音效播放准确率
- Task 3.5.9: 优化音效播放延迟

**Story Points**: 8
**Sprint**: Sprint 4
**Labels**: firmware, feature

---

#### Story 3.6: 4只设备互动时有节奏聚会音效

**用户故事**: 作为用户，我想要4只设备互动时有节奏聚会音效，以便体验"小型的茶话会。"的情感隐喻

**验收标准**:
- 发起者开启旋律哼唱
- 另外两只负责高低声部和声
- 性格最活泼（如快乐/愤怒）的一只自动充当"鼓手"，发出节奏性的气泡音："Pop...Pop...Du-ang!"
- 音效播放准确率 >= 95%
- 音效播放延迟 < 0.5秒

**业务规则**:
- 4只设备：节奏聚会（加入节奏组）
- 发起者开启旋律哼唱
- 另外两只负责高低声部和声
- 性格最活泼（如快乐/愤怒）的一只自动充当"鼓手"，发出节奏性的气泡音："Pop...Pop...Du-ang!"

**Task列表**:
- Task 3.6.1: 实现4只设备互动音效（节奏聚会）
- Task 3.6.2: 实现发起者旋律哼唱
- Task 3.6.3: 实现另外两只高低声部和声
- Task 3.6.4: 实现性格最活泼的设备充当"鼓手"
- Task 3.6.5: 实现节奏性气泡音播放（"Pop...Pop...Du-ang!"）
- Task 3.6.6: 编写4只设备互动音效的单元测试
- Task 3.6.7: 编写4只设备互动音效的集成测试
- Task 3.6.8: 优化音效播放准确率
- Task 3.6.9: 优化音效播放延迟

**Story Points**: 8
**Sprint**: Sprint 5
**Labels**: firmware, feature

---

#### Story 3.7: 5只设备互动时有混乱合唱音效

**用户故事**: 作为用户，我想要5只设备互动时有混乱合唱音效，以便体验"大家都在八卦人类！"的情感隐喻

**验收标准**:
- 声音此起彼伏，充满了"Gu-ji!"、"Ma-na!"等短词
- 中间会突然有一次整齐的静音（0.5s）
- 然后大家一起爆发出大笑声
- 音效播放准确率 >= 95%
- 音效播放延迟 < 0.5秒

**业务规则**:
- 5只设备：混乱合唱（热烈的讨论）
- 声音此起彼伏，充满了"Gu-ji!"、"Ma-na!"等短词
- 中间会突然有一次整齐的静音（0.5s）
- 然后大家一起爆发出大笑声

**Task列表**:
- Task 3.7.1: 实现5只设备互动音效（混乱合唱）
- Task 3.7.2: 实现此起彼伏的短词播放（"Gu-ji!"、"Ma-na!"）
- Task 3.7.3: 实现整齐静音（0.5s）
- Task 3.7.4: 实现大家一起爆发出大笑声
- Task 3.7.5: 编写5只设备互动音效的单元测试
- Task 3.7.6: 编写5只设备互动音效的集成测试
- Task 3.7.7: 优化音效播放准确率
- Task 3.7.8: 优化音效播放延迟

**Story Points**: 8
**Sprint**: Sprint 5
**Labels**: firmware, feature

---

#### Story 3.8: 6只设备互动时有星系共振音效

**用户故事**: 作为用户，我想要6只设备互动时有星系共振音效，以便体验"情绪晶核充能完毕。"的情感隐喻

**验收标准**:
- 所有小精灵先静默1秒
- 依次发出Do-Mi-Sol-Do-Mi-Sol的琶音
- 最后齐声发出一句空灵、带有混响感的长音："E-MO-MO——"
- 结束音效为清脆的风铃声
- 音效播放准确率 >= 95%
- 音效播放延迟 < 0.5秒

**业务规则**:
- 6只设备：星系共振（神圣时刻彩蛋）
- 所有小精灵先静默1秒
- 依次发出Do-Mi-Sol-Do-Mi-Sol的琶音
- 最后齐声发出一句空灵、带有混响感的长音："E-MO-MO——"
- 结束音效为清脆的风铃声

**Task列表**:
- Task 3.8.1: 实现6只设备互动音效（星系共振）
- Task 3.8.2: 实现所有小精灵静默1秒
- Task 3.8.3: 实现依次发出Do-Mi-Sol-Do-Mi-Sol的琶音
- Task 3.8.4: 实现齐声发出空灵长音（"E-MO-MO——"）
- Task 3.8.5: 实现结束音效（清脆的风铃声）
- Task 3.8.6: 编写6只设备互动音效的单元测试
- Task 3.8.7: 编写6只设备互动音效的集成测试
- Task 3.8.8: 优化音效播放准确率
- Task 3.8.9: 优化音效播放延迟

**Story Points**: 8
**Sprint**: Sprint 5
**Labels**: firmware, feature

---

#### Story 3.9: 电量不足的设备不参与多精灵发声

**用户故事**: 作为用户，我想要电量不足的设备不参与多精灵发声，以便避免设备突然关机

**验收标准**:
- 电量 < 15%时，设备不参与发声
- 电量 < 15%时，设备只微弱闪烁灯光
- 电量不足检测准确率 >= 95%

**业务规则**:
- 电量不足参与者：若某只电量 < 15%，它不会参与发声，只会微弱地闪烁灯光，表现出"想加入但没力气"的样子

**Task列表**:
- Task 3.9.1: 实现电量不足检测（电量 < 15%）
- Task 3.9.2: 实现电量不足时不参与发声
- Task 3.9.3: 实现电量不足时微弱闪烁灯光
- Task 3.9.4: 编写电量不足检测的单元测试
- Task 3.9.5: 编写电量不足检测的集成测试
- Task 3.9.6: 优化电量不足检测准确率

**Story Points**: 5
**Sprint**: Sprint 5
**Labels**: firmware, hardware, feature

---

### Epic 4: 社交功能

**Epic名称**: 社交功能
**Epic描述**: 基于物理硬件的好友系统，支持好友添加、关系维护、传声筒模式
**优先级**: High
**组件**: Cloud, App, Firmware

**划分思路**:
- 按照好友管理的生命周期划分Story：添加好友、查看好友列表、删除好友、传声筒模式
- 添加好友Story Points设为13，因为涉及设备ID生成、好友关系链建立、云端存储等复杂逻辑
- 查看好友列表Story Points设为8，因为主要是数据查询和展示，逻辑相对简单
- 删除好友Story Points设为5，因为主要是解除关系链，逻辑相对简单
- 传声筒模式Story Points设为8，因为涉及好友识别、语音传输、状态切换等逻辑

**设计理由**:
- 好友系统是社交功能的核心，需要设备ID、云端存储、App界面三端协同
- 添加好友是最复杂的操作，需要发起申请、确认关系、建立连接等多个步骤
- 查看和删除好友是相对简单的操作，可以快速实现
- 传声筒模式是语音社交功能，需要与好友系统结合，实现好友间的语音互动
- 好友关系链存在于设备与设备之间，App只是管理界面，这种设计确保了硬件的独立性
- 每个操作都有明确的验收标准和响应时间要求，确保用户体验

---

#### Story 4.1: 用户可以通过App添加好友

**用户故事**: 作为用户，我想要通过App添加好友，以便与其他kikigo用户建立好友关系

**验收标准**:
- 每台小精灵拥有唯一的设备ID
- 好友关系链存在于设备与设备之间
- App作为管理界面，负责发起申请、确认关系及维护信息
- 好友添加成功率 >= 95%
- 好友添加响应时间 < 3秒

**业务规则**:
- 好友系统核心定义：社交主体标识基于物理硬件
- 好友关系的建立基于物理硬件。每一台小精灵拥有唯一的设备ID
- 好友关系链存在于设备与设备之间，App作为管理界面，负责发起申请、确认关系及维护信息

**Task列表**:
- Task 4.1.1: 设计设备ID生成算法
- Task 4.1.2: 实现设备ID存储和管理
- Task 4.1.3: 设计好友关系链数据结构
- Task 4.1.4: 实现好友申请功能（App端）
- Task 4.1.5: 实现好友确认功能（App端）
- Task 4.1.6: 实现好友信息维护功能（App端）
- Task 4.1.7: 实现好友关系链存储（云端）
- Task 4.1.8: 编写好友添加的单元测试
- Task 4.1.9: 编写好友添加的集成测试
- Task 4.1.10: 优化好友添加成功率
- Task 4.1.11: 优化好友添加响应时间

**Story Points**: 13
**Sprint**: Sprint 6
**Labels**: cloud, app, firmware, feature

---

#### Story 4.2: 用户可以通过App查看好友列表

**用户故事**: 作为用户，我想要通过App查看好友列表，以便了解我的好友关系

**验收标准**:
- App能够显示好友列表
- 好友列表包含好友的设备ID、昵称、在线状态等信息
- 好友列表加载时间 < 2秒

**业务规则**:
- 好友列表显示好友的设备ID、昵称、在线状态等信息

**Task列表**:
- Task 4.2.1: 设计好友列表UI（App端）
- Task 4.2.2: 实现好友列表数据获取（App端）
- Task 4.2.3: 实现好友列表显示（App端）
- Task 4.2.4: 实现好友在线状态更新
- Task 4.2.5: 编写好友列表的单元测试
- Task 4.2.6: 编写好友列表的集成测试
- Task 4.2.7: 优化好友列表加载时间

**Story Points**: 8
**Sprint**: Sprint 6
**Labels**: app, cloud, feature

---

#### Story 4.3: 用户可以通过App删除好友

**用户故事**: 作为用户，我想要通过App删除好友，以便解除好友关系

**验收标准**:
- App能够删除好友
- 删除好友后，好友关系链解除
- 删除好友成功率 >= 95%
- 删除好友响应时间 < 2秒

**业务规则**:
- 删除好友后，好友关系链解除

**Task列表**:
- Task 4.3.1: 设计删除好友UI（App端）
- Task 4.3.2: 实现删除好友功能（App端）
- Task 4.3.3: 实现好友关系链解除（云端）
- Task 4.3.4: 编写删除好友的单元测试
- Task 4.3.5: 编写删除好友的集成测试
- Task 4.3.6: 优化删除好友成功率
- Task 4.3.7: 优化删除好友响应时间

**Story Points**: 5
**Sprint**: Sprint 6
**Labels**: app, cloud, feature

---

#### Story 4.4: 用户可以通过语音指令进入传声筒模式

**用户故事**: 作为用户，我想要通过语音指令进入传声筒模式，以便与好友进行语音互动

**验收标准**:
- 设备能够识别传声筒指令"Kiki，呼叫xxx"或"Kiki，帮我找xxx"
- 进入传声筒模式后，设备进入传声筒模式状态
- 传声筒模式识别准确率 >= 95%
- 传声筒模式响应时间 < 2秒

**业务规则**:
- 传声筒指令："Kiki，呼叫xxx"、"Kiki，帮我找xxx"
- 进入传声筒模式后，设备进入传声筒模式状态
- 传声筒模式需要与好友系统结合，识别好友并建立语音连接

**Task列表**:
- Task 4.4.1: 实现传声筒指令识别算法
- Task 4.4.2: 实现传声筒模式状态切换
- Task 4.4.3: 实现传声筒模式的好友识别
- Task 4.4.4: 实现传声筒模式的语音传输
- Task 4.4.5: 编写传声筒识别的单元测试
- Task 4.4.6: 编写传声筒识别的集成测试
- Task 4.4.7: 优化传声筒识别准确率
- Task 4.4.8: 优化传声筒模式响应时间

**Story Points**: 8
**Sprint**: Sprint 6
**Labels**: ai, firmware, cloud, feature

---

### Epic 5: 物理按键系统

**Epic名称**: 物理按键系统
**Epic描述**: 通过物理按键控制设备状态和功能
**优先级**: Medium
**组件**: Hardware, Firmware

**划分思路**:
- 将所有物理按键功能合并为一个Story，因为物理按键功能相对独立且集中
- Story Points设为8，因为涉及硬件设计、按键检测、功能映射等多个环节

**设计理由**:
- 物理按键是语音控制的补充，提供不使用语音的交互方式
- 所有物理按键功能集中在一个Story中，便于统一管理和测试
- 物理按键的响应时间要求更严格（< 0.5秒），需要硬件和固件协同优化
- 物理按键的具体功能定义在PRD中，这里只负责实现检测和映射逻辑
- 优先级设为Medium，因为语音控制是主要的交互方式，物理按键是辅助功能

---

#### Story 5.1: 用户可以通过物理按键控制设备

**用户故事**: 作为用户，我想要通过物理按键控制设备，以便在不使用语音的情况下操作设备

**验收标准**:
- 物理按键能够控制设备状态和功能
- 物理按键响应时间 < 0.5秒
- 物理按键准确率 >= 95%

**业务规则**:
- 支持通过物理按键进行设备控制（具体按键定义见PRD 3.2.2节）

**Task列表**:
- Task 5.1.1: 设计物理按键布局（硬件）
- Task 5.1.2: 实现物理按键检测（固件）
- Task 5.1.3: 实现物理按键功能映射（固件）
- Task 5.1.4: 编写物理按键的单元测试
- Task 5.1.5: 编写物理按键的集成测试
- Task 5.1.6: 优化物理按键准确率
- Task 5.1.7: 优化物理按键响应时间

**Story Points**: 8
**Sprint**: Sprint 3
**Labels**: hardware, firmware, feature

---

### Epic 6: 灯光交互系统

**Epic名称**: 灯光交互系统
**Epic描述**: 通过灯光效果表达情绪和状态
**优先级**: High
**组件**: Hardware, Firmware

**划分思路**:
- 按照灯光功能类型划分Story：情绪状态灯光、设备状态灯光
- 情绪状态灯光Story Points设为8，因为需要实现5种不同情绪的灯光效果，每种效果都有独特的颜色和动画
- 设备状态灯光Story Points设为5，因为只有3种状态灯光（环境光、唤醒光效、待唤醒光效），相对简单

**设计理由**:
- 灯光是设备与用户沟通的重要方式，能够直观地表达情绪和状态
- 情绪状态灯光需要覆盖5种人格，每种人格都有独特的灯光特征，实现复杂度较高
- 设备状态灯光相对简单，主要是不同状态下的灯光切换
- 灯光效果的平滑切换和准确率是用户体验的关键，需要重点优化
- 优先级设为High，因为灯光是设备的主要交互方式之一

---

#### Story 6.1: 设备能够通过灯光表达不同情绪状态

**用户故事**: 作为用户，我想要设备能够通过灯光表达不同情绪状态，以便直观地了解设备的情绪状态

**验收标准**:
- 设备能够根据不同情绪状态显示不同的灯光效果
- 灯光效果包括：快乐、愤怒、悲伤、焦虑、宁静
- 灯光效果切换平滑，无明显延迟
- 灯光效果准确率 >= 95%

**业务规则**:
- 支持不同情绪状态的灯光表达
- 快乐：明亮、快速闪烁
- 愤怒：红色、急促闪烁
- 悲伤：蓝色、缓慢呼吸
- 焦虑：黄色、不规则闪烁
- 宁静：绿色、平稳呼吸

**Task列表**:
- Task 6.1.1: 设计不同情绪状态的灯光效果
- Task 6.1.2: 实现快乐灯光效果
- Task 6.1.3: 实现愤怒灯光效果
- Task 6.1.4: 实现悲伤灯光效果
- Task 6.1.5: 实现焦虑灯光效果
- Task 6.1.6: 实现宁静灯光效果
- Task 6.1.7: 实现灯光效果平滑切换
- Task 6.1.8: 编写灯光效果的单元测试
- Task 6.1.9: 编写灯光效果的集成测试
- Task 6.1.10: 优化灯光效果准确率

**Story Points**: 8
**Sprint**: Sprint 3
**Labels**: hardware, firmware, feature

---

#### Story 6.2: 设备能够显示环境光、唤醒光效、待唤醒光效

**用户故事**: 作为用户，我想要设备能够显示环境光、唤醒光效、待唤醒光效，以便了解设备的不同状态

**验收标准**:
- 设备能够显示环境光
- 设备能够显示唤醒光效
- 设备能够显示待唤醒光效
- 灯光效果准确率 >= 95%

**业务规则**:
- 环境光：默认的灯光效果
- 唤醒光效：唤醒时的灯光效果
- 待唤醒光效：待机时的灯光效果

**Task列表**:
- Task 6.2.1: 设计环境光效果
- Task 6.2.2: 设计唤醒光效
- Task 6.2.3: 设计待唤醒光效
- Task 6.2.4: 实现环境光效果
- Task 6.2.5: 实现唤醒光效
- Task 6.2.6: 实现待唤醒光效
- Task 6.2.7: 编写灯光效果的单元测试
- Task 6.2.8: 编写灯光效果的集成测试
- Task 6.2.9: 优化灯光效果准确率

**Story Points**: 5
**Sprint**: Sprint 3
**Labels**: hardware, firmware, feature

---

### Epic 7: 电量管理系统

**Epic名称**: 电量管理系统
**Epic描述**: 监控设备电量，提供电量不足提示
**优先级**: High
**组件**: Hardware, Firmware

**划分思路**:
- 将所有电量管理功能合并为一个Story，因为电量管理是一个相对独立且集中的功能
- Story Points设为5，因为主要是硬件监控和固件逻辑，实现相对简单

**设计理由**:
- 电量管理是设备稳定运行的基础，必须确保电量监控的准确性
- 电量不足时设备不参与发声，这是系统稳定性的重要保障
- 电量不足提示包括灯光和声音，提供多感官反馈
- 优先级设为High，因为电量不足会影响所有功能的正常运行
- 电量监控准确率要求 >= 95%，确保用户能够及时了解电量状态

---

#### Story 7.1: 设备能够监控电量并提供电量不足提示

**用户故事**: 作为用户，我想要设备能够监控电量并提供电量不足提示，以便及时充电

**验收标准**:
- 设备能够实时监控电量
- 设备能够在电量不足时提供提示
- 电量不足提示包括灯光和声音
- 电量监控准确率 >= 95%

**业务规则**:
- 电量 < 15%时，设备不参与多精灵发声，只微弱闪烁灯光
- 提供电量不足状态提示

**Task列表**:
- Task 7.1.1: 实现电量监控（硬件）
- Task 7.1.2: 实现电量不足检测（固件）
- Task 7.1.3: 实现电量不足灯光提示
- Task 7.1.4: 实现电量不足声音提示
- Task 7.1.5: 编写电量管理的单元测试
- Task 7.1.6: 编写电量管理的集成测试
- Task 7.1.7: 优化电量监控准确率

**Story Points**: 5
**Sprint**: Sprint 5
**Labels**: hardware, firmware, feature

---

### Epic 8: 敏感词过滤系统

**Epic名称**: 敏感词过滤系统
**Epic描述**: 对用户输入进行敏感词过滤，确保内容安全
**优先级**: High
**组件**: Cloud, AI/ML

**划分思路**:
- 将所有敏感词过滤功能合并为一个Story，因为敏感词过滤是一个相对独立且集中的功能
- Story Points设为5，因为主要是云端过滤逻辑，实现相对简单

**设计理由**:
- 敏感词过滤是内容安全的重要保障，必须确保过滤的准确性和及时性
- 敏感词过滤在云端进行，可以实时更新敏感词库，提高过滤效果
- 敏感词过滤响应时间要求 < 1秒，确保用户体验不会受到影响
- 优先级设为High，因为内容安全是产品的重要要求
- 敏感词过滤准确率要求 >= 95%，确保能够有效识别和过滤敏感内容
- 敏感词过滤策略在PRD中定义，这里只负责实现过滤逻辑

---

#### Story 8.1: 系统能够过滤用户输入的敏感词

**用户故事**: 作为用户，我想要系统能够过滤用户输入的敏感词，以便确保内容安全

**验收标准**:
- 系统能够识别用户输入中的敏感词
- 系统能够过滤敏感词
- 敏感词过滤准确率 >= 95%
- 敏感词过滤响应时间 < 1秒

**业务规则**:
- 实施敏感词过滤策略（详见PRD 3.1.7节）

**Task列表**:
- Task 8.1.1: 设计敏感词库
- Task 8.1.2: 实现敏感词识别算法
- Task 8.1.3: 实现敏感词过滤逻辑
- Task 8.1.4: 实现敏感词过滤反馈
- Task 8.1.5: 编写敏感词过滤的单元测试
- Task 8.1.6: 编写敏感词过滤的集成测试
- Task 8.1.7: 优化敏感词过滤准确率
- Task 8.1.8: 优化敏感词过滤响应时间

**Story Points**: 8
**Sprint**: Sprint 7
**Labels**: cloud, ai, feature

---

## 依赖关系图

```mermaid
graph TD
    E1[Epic 1: 小精灵人设和语言风格系统] --> S1.1[Story 1.1: 快乐人格]
    E1 --> S1.2[Story 1.2: 愤怒人格]
    E1 --> S1.3[Story 1.3: 悲伤人格]
    E1 --> S1.4[Story 1.4: 焦虑人格]
    E1 --> S1.5[Story 1.5: 宁静人格]
    E1 --> S1.6[Story 1.6: 人格自动切换]
    S1.1 --> S1.6
    S1.2 --> S1.6
    S1.3 --> S1.6
    S1.4 --> S1.6
    S1.5 --> S1.6

    E2[Epic 2: 语音系统] --> S2.1[Story 2.1: 设备状态控制]
    E2 --> S2.2[Story 2.2: 睡眠模式切换]
    E2 --> S2.3[Story 2.3: 音量调整]
    E2 --> S2.4[Story 2.4: 亮度调整]

    E3[Epic 3: 多精灵交互系统] --> S3.1[Story 3.1: 触发互动]
    E3 --> S3.2[Story 3.2: 防打扰逻辑]
    E3 --> S3.3[Story 3.3: 角色分配]
    E3 --> S3.4[Story 3.4: 2只设备音效]
    E3 --> S3.5[Story 3.5: 3只设备音效]
    E3 --> S3.6[Story 3.6: 4只设备音效]
    E3 --> S3.7[Story 3.7: 5只设备音效]
    E3 --> S3.8[Story 3.8: 6只设备音效]
    E3 --> S3.9[Story 3.9: 电量不足处理]
    S3.1 --> S3.2
    S3.1 --> S3.3
    S3.3 --> S3.4
    S3.3 --> S3.5
    S3.3 --> S3.6
    S3.3 --> S3.7
    S3.3 --> S3.8
    S3.2 --> S3.9

    E4[Epic 4: 社交功能] --> S4.1[Story 4.1: 添加好友]
    E4 --> S4.2[Story 4.2: 查看好友列表]
    E4 --> S4.3[Story 4.3: 删除好友]
    E4 --> S4.4[Story 4.4: 传声筒模式]
    S4.1 --> S4.2
    S4.1 --> S4.3
    S4.1 --> S4.4

    E5[Epic 5: 物理按键系统] --> S5.1[Story 5.1: 物理按键控制]

    E6[Epic 6: 灯光交互系统] --> S6.1[Story 6.1: 情绪灯光]
    E6 --> S6.2[Story 6.2: 状态灯光]

    E7[Epic 7: 电量管理系统] --> S7.1[Story 7.1: 电量监控]

    E8[Epic 8: 敏感词过滤系统] --> S8.1[Story 8.1: 敏感词过滤]

    S1.6 -.-> S2.1
    S2.1 -.-> S2.2
    S2.1 -.-> S2.3
    S2.1 -.-> S2.4
    S2.2 -.-> S3.2
    S3.1 -.-> S3.4
    S3.1 -.-> S3.5
    S3.1 -.-> S3.6
    S3.1 -.-> S3.7
    S3.1 -.-> S3.8
    S7.1 -.-> S3.9
```

---

## Sprint规划

### Sprint 1: 需求分析、技术方案设计

**目标**: 完成需求分析和技术方案设计

**Story列表**:
- 无（主要是分析和设计工作）

**Task列表**:
- Task 1.1: 完成需求分析文档
- Task 1.2: 完成技术方案设计
- Task 1.3: 完成架构设计
- Task 1.4: 完成数据库设计
- Task 1.5: 完成API设计
- Task 1.6: 完成UI/UX设计

**Story Points**: 0
**Sprint**: Sprint 1

---

### Sprint 2: 核心功能开发（人设系统、语音系统）

**目标**: 完成人设系统和语音系统的核心功能开发

**Story列表**:
- Story 1.1: 用户可以体验快乐人格的陪伴（8 SP）
- Story 1.2: 用户可以体验愤怒人格的陪伴（8 SP）
- Story 1.3: 用户可以体验悲伤人格的陪伴（8 SP）
- Story 1.4: 用户可以体验焦虑人格的陪伴（8 SP）
- Story 1.5: 用户可以体验宁静人格的陪伴（8 SP）
- Story 2.1: 用户可以通过语音指令唤醒设备（13 SP）
- Story 2.2: 用户可以通过语音指令让设备进入待机状态（8 SP）

**Story Points**: 61
**Sprint**: Sprint 2

---

### Sprint 3: 核心功能开发（语音系统、灯光交互、物理按键）

**目标**: 完成语音系统、灯光交互和物理按键的开发

**Story列表**:
- Story 1.6: 用户可以根据情绪状态自动切换人格（13 SP）
- Story 2.4: 用户可以通过语音指令开启睡眠模式（8 SP）
- Story 2.5: 用户可以通过语音指令关闭睡眠模式（8 SP）
- Story 2.6: 用户可以通过语音指令调整音量（8 SP）
- Story 2.7: 用户可以通过语音指令调整亮度（8 SP）
- Story 5.1: 用户可以通过物理按键控制设备（8 SP）
- Story 6.1: 设备能够通过灯光表达不同情绪状态（8 SP）
- Story 6.2: 设备能够显示环境光、唤醒光效、待唤醒光效（5 SP）

**Story Points**: 66
**Sprint**: Sprint 3

---

### Sprint 4: 多精灵交互系统开发（1）

**目标**: 完成多精灵交互系统的触发、防打扰、角色分配和2-3只设备音效

**Story列表**:
- Story 3.1: 多台设备靠近时可以触发互动（13 SP）
- Story 3.2: 多精灵互动有防打扰逻辑（8 SP）
- Story 3.3: 多精灵互动有角色分配机制（5 SP）
- Story 3.4: 2只设备互动时有双机问候音效（5 SP）
- Story 3.5: 3只设备互动时有三角和声音效（8 SP）

**Story Points**: 39
**Sprint**: Sprint 4

---

### Sprint 5: 多精灵交互系统开发（2）

**目标**: 完成多精灵交互系统的4-6只设备音效和电量管理

**Story列表**:
- Story 3.6: 4只设备互动时有节奏聚会音效（8 SP）
- Story 3.7: 5只设备互动时有混乱合唱音效（8 SP）
- Story 3.8: 6只设备互动时有星系共振音效（8 SP）
- Story 3.9: 电量不足的设备不参与多精灵发声（5 SP）
- Story 7.1: 设备能够监控电量并提供电量不足提示（5 SP）

**Story Points**: 34
**Sprint**: Sprint 5

---

### Sprint 6: 社交功能开发

**目标**: 完成社交功能的开发

**Story列表**:
- Story 2.3: 用户可以通过语音指令进入传声筒模式（8 SP）
- Story 4.1: 用户可以通过App添加好友（13 SP）
- Story 4.2: 用户可以通过App查看好友列表（8 SP）
- Story 4.3: 用户可以通过App删除好友（5 SP）

**Story Points**: 34
**Sprint**: Sprint 6

---

### Sprint 7: 敏感词过滤和优化

**目标**: 完成敏感词过滤系统和性能优化

**Story列表**:
- Story 8.1: 系统能够过滤用户输入的敏感词（8 SP）

**Task列表**:
- Task 7.1: 优化语音识别准确率
- Task 7.2: 优化语音识别响应时间
- Task 7.3: 优化多精灵交互响应时间
- Task 7.4: 优化音效播放延迟
- Task 7.5: 优化情绪识别准确率

**Story Points**: 8
**Sprint**: Sprint 7

---

### Sprint 8: 测试和Bug修复

**目标**: 完成系统测试和Bug修复

**Task列表**:
- Task 8.1: 执行系统测试
- Task 8.2: 执行集成测试
- Task 8.3: 执行性能测试
- Task 8.4: 执行兼容性测试
- Task 8.5: 修复发现的Bug
- Task 8.6: 回归测试

**Story Points**: 0
**Sprint**: Sprint 8

---

### Sprint 9: 优化和改进

**目标**: 完成系统优化和改进

**Task列表**:
- Task 9.1: 优化用户体验
- Task 9.2: 优化系统性能
- Task 9.3: 优化代码质量
- Task 9.4: 完善文档
- Task 9.5: 准备发布

**Story Points**: 0
**Sprint**: Sprint 9

---

### Sprint 10: 发布准备

**目标**: 完成发布准备

**Task列表**:
- Task 10.1: 完成发布测试
- Task 10.2: 准备发布材料
- Task 10.3: 准备用户文档
- Task 10.4: 准备运维文档
- Task 10.5: 执行发布
- Task 10.6: 发布后监控

**Story Points**: 0
**Sprint**: Sprint 10

---

## 下一步

确认Jira Issue拆分后，将进入**阶段4: Approve（测试方案审批）**，确认Jira项目设计方案的完整性和可行性。

</textarea>

<script>
    // Initialize mermaid
    mermaid.initialize({ startOnLoad: false, theme: 'default' });

    const mdSource = document.getElementById('md-source').value;
    
    // Custom renderer for marked to handle mermaid code blocks
    const renderer = new marked.Renderer();
    const originalCodeRenderer = renderer.code.bind(renderer);
    
    renderer.code = function(code, language) {
        if (language === 'mermaid') {
            return '<div class="mermaid">' + code + '</div>';
        }
        return originalCodeRenderer(code, language);
    };

    // Parse markdown
    document.getElementById('content').innerHTML = marked.parse(mdSource, { renderer: renderer });

    // Run mermaid
    mermaid.run({
        nodes: document.querySelectorAll('.mermaid')
    });
</script>
</body>
</html>
