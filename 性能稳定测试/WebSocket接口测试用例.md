# WebSocket 接口测试用例

## 1. 文档说明

### 1.1 目的
本文档基于湃启WebSocket通信协议文档1.0和小精灵测试用例完整版，设计了全面的WebSocket接口测试用例，旨在验证WebSocket通信协议的正确性、稳定性和性能。

### 1.2 适用范围
- WebSocket通信协议测试
- 设备端与服务器端的交互测试
- 语音识别、合成和控制功能测试
- 错误处理和异常场景测试
- 性能和稳定性测试

### 1.3 术语定义
- **WebSocket**：一种全双工通信协议，用于在客户端和服务器之间建立持久连接
- **STT**：语音转文本（Speech to Text）
- **TTS**：文本转语音（Text to Speech）
- **MCP**：设备控制协议（Machine Control Protocol）
- **ASR**：自动语音识别（Automatic Speech Recognition）
- **Opus**：一种有损声音编码格式

## 2. 测试用例设计

### 2.1 测试策略
- **功能测试**：验证WebSocket协议的所有核心功能
- **异常测试**：验证系统对各种异常情况的处理能力
- **边界测试**：验证系统对边界值的处理能力
- **性能测试**：验证系统在高负载下的性能表现
- **稳定性测试**：验证系统的长期稳定运行能力

### 2.2 测试用例结构
每个测试用例包含以下部分：
- **测试用例ID**：唯一标识符，格式为TC-XXX-XXX
- **测试场景**：描述测试的具体场景
- **操作步骤**：详细的测试操作步骤
- **预期结果**：测试执行后应达到的预期结果

## 3. 测试用例

---

### 模块1：连接管理测试

#### TC-001-001 正常连接建立_P0
- **测试场景**：使用正确的URL和参数建立WebSocket连接
- **操作步骤**：
  1. 构造WebSocket URL：`ws://118.196.28.154:8460/?device_id=test_device_001&user_id=test_user_001`
  2. 使用WebSocket客户端发起连接请求
  3. 观察连接状态和服务器响应
- **预期结果**：
  - WebSocket连接成功建立
  - 连接状态为OPEN
  - 无错误信息

#### TC-001-002 无效URL参数_P0
- **测试场景**：使用缺少必要参数的URL建立连接
- **操作步骤**：
  1. 构造缺少device_id的URL：`ws://118.196.28.154:8460/?user_id=test_user_001`
  2. 发起连接请求
  3. 观察连接状态
- **预期结果**：
  - 服务器拒绝连接
  - 返回适当的错误信息
  - 或接受连接并使用默认值

#### TC-001-003 连接超时_P0
- **测试场景**：服务器不可用时建立连接
- **操作步骤**：
  1. 构造无效的URL：`ws://invalid_host:8460/?device_id=test&user_id=test`
  2. 发起连接请求
  3. 设置合理的超时时间（如5秒）
  4. 观察连接状态
- **预期结果**：
  - 连接超时
  - 客户端捕获到超时异常
  - 无资源泄漏

#### TC-001-004 连接断开重连_P0
- **测试场景**：连接断开后自动重连
- **操作步骤**：
  1. 建立正常的WebSocket连接
  2. 服务器主动断开连接
  3. 观察客户端重连行为
  4. 重连后进行正常交互
- **预期结果**：
  - 客户端检测到连接断开
  - 自动尝试重连
  - 重连成功后恢复正常通信
  - 无需人工干预

---

### 模块2：握手协议测试

#### TC-002-001 正常握手流程_P0
- **测试场景**：设备端发送hello消息进行握手
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送hello消息：
     ```json
     {
       "type": "hello",
       "version": 1,
       "features": {
         "mcp": true
       },
       "transport": "websocket",
       "audio_params": {
         "format": "opus",
         "sample_rate": 16000,
         "channels": 1,
         "frame_duration": 60
       },
       "device_id": "test_device_001",
       "device_name": "测试设备",
       "user_id": "test_user_001",
       "trace_id": "test_trace_001",
       "device_mac": "00:11:22:33:44:55",
       "client_id": "test_client_001",
       "client_ip": "192.168.1.100",
       "client_info": {
         "os_type": "Android",
         "os_version": "14",
         "app_version": "1.2.3",
         "network_type": "wifi",
         "network_provider": "CMCC",
         "timezone": "Asia/Shanghai",
         "country_code": "CN",
         "battery_level": 76,
         "is_charging": true
       }
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回hello响应
  - 包含session_id等必要字段
  - audio_params返回正确
  - 握手成功

#### TC-002-002 简化握手消息_P0
- **测试场景**：发送缺少可选字段的hello消息
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送简化的hello消息：
     ```json
     {
       "type": "hello",
       "version": 1,
       "transport": "websocket",
       "audio_params": {
         "format": "opus",
         "sample_rate": 16000,
         "channels": 1,
         "frame_duration": 60
       },
       "device_id": "test_device_001",
       "user_id": "test_user_001"
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回hello响应
  - 使用默认值填充缺少的字段
  - 握手成功

#### TC-002-003 错误的版本号_P0
- **测试场景**：发送错误的version值
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送错误版本号的hello消息：
     ```json
     {
       "type": "hello",
       "version": 999,
       "transport": "websocket",
       "audio_params": {
         "format": "opus",
         "sample_rate": 16000,
         "channels": 1,
         "frame_duration": 60
       },
       "device_id": "test_device_001",
       "user_id": "test_user_001"
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回error消息
  - message字段描述版本错误
  - 或使用默认版本号进行握手

#### TC-002-004 重复握手_P1
- **测试场景**：多次发送hello消息
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送第一次hello消息，完成握手
  3. 再次发送hello消息
  4. 观察服务器响应
- **预期结果**：
  - 服务器忽略重复的hello消息
  - 或返回error消息
  - 连接保持正常

---

### 模块3：语音监听测试

#### TC-003-001 开始监听_P0
- **测试场景**：发送listen消息开始监听
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 发送listen消息：
     ```json
     {
       "session_id": "会话标识",
       "type": "listen",
       "state": "start",
       "mode": "auto"
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器接受listen请求
  - 准备接收音频数据
  - 无错误返回

#### TC-003-002 停止监听_P0
- **测试场景**：发送listen消息停止监听
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 发送start listen消息
  3. 发送stop listen消息：
     ```json
     {
       "session_id": "会话标识",
       "type": "listen",
       "state": "stop"
     }
     ```
  4. 观察服务器响应
- **预期结果**：
  - 服务器接受stop请求
  - 停止接收音频数据
  - 无错误返回

#### TC-003-003 检测到语音_P0
- **测试场景**：发送detect listen消息
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 发送detect listen消息：
     ```json
     {
       "session_id": "会话标识",
       "type": "listen",
       "state": "detect",
       "text": "小精灵"
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器接受detect请求
  - 开始处理语音识别
  - 返回相应的stt结果

#### TC-003-004 无效的listen状态_P1
- **测试场景**：发送无效的listen state
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 发送无效状态的listen消息：
     ```json
     {
       "session_id": "会话标识",
       "type": "listen",
       "state": "invalid_state"
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回error消息
  - message字段描述无效状态
  - 连接保持正常

---

### 模块4：TTS播放测试

#### TC-004-001 TTS开始播放_P0
- **测试场景**：验证TTS播放的完整流程
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 发送音频数据触发TTS响应
  3. 观察服务器发送的TTS相关消息
  4. 接收并播放TTS音频数据
- **预期结果**：
  - 收到tts state=start消息
  - 收到tts state=sentence_start消息
  - 收到TTS音频数据
  - 收到tts state=sentence_end消息
  - 收到tts state=stop消息
  - TTS音频正常播放

#### TC-004-002 TTS类型测试_P0
- **测试场景**：测试不同tts_type的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发不同类型的TTS响应（text, ssml等）
  3. 观察tts消息中的tts_type字段
  4. 验证音频播放效果
- **预期结果**：
  - 不同tts_type字段被正确返回
  - 音频播放效果符合预期
  - 无错误发生

#### TC-004-003 TTS情绪标签_P1
- **测试场景**：验证TTS情绪标签的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发带有情绪标签的TTS响应
  3. 观察tts消息中的emotion_tag字段
  4. 验证音频播放的情绪效果
- **预期结果**：
  - emotion_tag字段被正确返回
  - 音频播放带有相应的情绪效果
  - 无错误发生

#### TC-004-004 多句子TTS_P1
- **测试场景**：测试多句子TTS的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发包含多个句子的TTS响应
  3. 观察tts消息的顺序和内容
  4. 验证音频播放效果
- **预期结果**：
  - 每个句子都有对应的sentence_start和sentence_end消息
  - index字段递增
  - 音频按顺序播放
  - 无句子丢失或顺序错误

---

### 模块5：MCP控制测试

#### TC-005-001 退出对话_P0
- **测试场景**：验证exit MCP指令的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发服务器发送exit指令：
     ```json
     {
       "type": "mcp",
       "session_id": "会话标识",
       "payload": {
         "jsonrpc": "2.0",
         "method": "exit",
         "params": {
           "say_goodbye": "回帕奇星系啦～"
         }
       }
     }
     ```
  3. 观察设备端行为
- **预期结果**：
  - 设备端正确解析exit指令
  - 播放指定的告别语
  - 结束当前对话会话
  - 回到空闲状态

#### TC-005-002 播放音乐_P0
- **测试场景**：验证play_music MCP指令的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发服务器发送play_music指令：
     ```json
     {
       "type": "mcp",
       "session_id": "会话标识",
       "payload": {
         "jsonrpc": "2.0",
         "method": "play_music",
         "params": {
           "song_name": "两只老虎"
         }
       }
     }
     ```
  3. 观察设备端行为
- **预期结果**：
  - 设备端正确解析play_music指令
  - 播放指定的音乐
  - 播放状态正确

#### TC-005-003 设置音量_P0
- **测试场景**：验证set_volume MCP指令的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发服务器发送set_volume指令：
     ```json
     {
       "type": "mcp",
       "session_id": "会话标识",
       "payload": {
         "jsonrpc": "2.0",
         "method": "set_volume",
         "params": {
           "volume": 50
         }
       }
     }
     ```
  3. 观察设备端音量变化
- **预期结果**：
  - 设备端正确解析set_volume指令
  - 音量被设置为指定值
  - 音量变化明显

#### TC-005-004 调节音量_P0
- **测试场景**：验证adjust_volume MCP指令的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发服务器发送adjust_volume指令：
     ```json
     {
       "type": "mcp",
       "session_id": "会话标识",
       "payload": {
         "jsonrpc": "2.0",
         "method": "adjust_volume",
         "params": {
           "adjustment": 20
         }
       }
     }
     ```
  3. 观察设备端音量变化
- **预期结果**：
  - 设备端正确解析adjust_volume指令
  - 音量在当前基础上增加指定值
  - 音量变化符合预期

---

### 模块6：表情控制测试

#### TC-006-001 发送表情指令_P0
- **测试场景**：验证emoji消息的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发服务器发送emoji消息：
     ```json
     {
       "session_id": "会话标识",
       "type": "emoji",
       "version": 1,
       "transport": "websocket",
       "talk_rounds": 1,
       "emoji_map": "3"
     }
     ```
  3. 观察设备端表情变化
- **预期结果**：
  - 设备端正确解析emoji消息
  - 显示对应的表情
  - 表情显示正常

#### TC-006-002 不同表情编码_P0
- **测试场景**：测试不同emoji_map值的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发服务器发送不同emoji_map值的emoji消息
  3. 观察设备端显示的表情
- **预期结果**：
  - 不同emoji_map值对应不同表情
  - 表情显示正确
  - 无错误发生

#### TC-006-003 无效表情编码_P1
- **测试场景**：测试无效emoji_map值的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发服务器发送无效emoji_map值的emoji消息：
     ```json
     {
       "session_id": "会话标识",
       "type": "emoji",
       "version": 1,
       "transport": "websocket",
       "talk_rounds": 1,
       "emoji_map": "999"
     }
     ```
  3. 观察设备端行为
- **预期结果**：
  - 设备端忽略无效表情编码
  - 或显示默认表情
  - 无错误发生
  - 不影响其他功能

---

### 模块7：二进制音频测试

#### TC-007-001 发送Opus音频数据_P0
- **测试场景**：发送Opus格式的音频数据
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 发送listen消息开始监听
  3. 发送Opus格式的音频数据
  4. 观察服务器响应
- **预期结果**：
  - 服务器接收音频数据
  - 返回stt消息包含识别结果
  - 识别结果正确
  - 无错误发生

#### TC-007-002 不同采样率音频_P0
- **测试场景**：测试不同采样率的音频处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 使用不同采样率（8000, 16000, 24000）的音频数据
  3. 分别发送音频数据
  4. 观察识别结果
- **预期结果**：
  - 服务器正确处理不同采样率的音频
  - 识别结果准确
  - 无错误发生

#### TC-007-003 二进制协议版本测试_P1
- **测试场景**：测试不同二进制协议版本的处理
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 测试二进制协议版本1：直接发送Opus数据
  3. 测试二进制协议版本2：发送带时间戳的二进制数据
  4. 测试二进制协议版本3：发送简化的二进制数据
  5. 观察服务器响应
- **预期结果**：
  - 服务器正确处理不同版本的二进制数据
  - 返回正确的stt结果
  - 无错误发生

---

### 模块8：打断功能测试

#### TC-008-001 正常打断流程_P0
- **测试场景**：发送interrupt消息打断TTS播放
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发TTS播放
  3. 在TTS播放过程中发送interrupt消息：
     ```json
     {
       "session_id": "会话标识",
       "type": "interrupt"
     }
     ```
  4. 观察服务器响应和TTS状态
- **预期结果**：
  - 服务器返回tts state=stop消息，reason=interrupt
  - 服务器返回interrupt_complete消息
  - TTS播放停止
  - 可以继续进行交互

#### TC-008-002 打断后TTS停止_P0
- **测试场景**：验证打断后TTS确实停止
- **操作步骤**：
  1. 建立WebSocket连接并完成握手
  2. 触发长文本TTS播放
  3. 发送interrupt消息
  4. 观察是否还有TTS音频数据发送
- **预期结果**：
  - TTS音频数据停止发送
  - 收到interrupt_complete消息
  - 无后续TTS相关消息

#### TC-008-003 多次打断请求_P0
- **测试场景**：连续发送多个interrupt消息
- **操作步骤**：
  1. 触发TTS播放
  2. 在TTS播放过程中连续发送3个interrupt消息
  3. 观察服务器响应和TTS状态
- **预期结果**：
  - 服务器只处理第一个interrupt消息
  - TTS正常停止播放
  - 返回interrupt_complete消息
  - 后续的interrupt消息被忽略或返回错误

#### TC-008-004 打断后继续监听_P0
- **测试场景**：打断后继续发送语音数据
- **操作步骤**：
  1. 触发TTS播放
  2. 发送interrupt消息打断TTS
  3. 等待interrupt_complete响应
  4. 继续发送音频数据
- **预期结果**：
  - TTS被成功打断
  - ASR继续识别后续的语音
  - 返回新的stt消息
  - 可以触发新的TTS播放

#### TC-008-005 无播放时打断_P1
- **测试场景**：在没有TTS播放时发送interrupt消息
- **操作步骤**：
  1. 建立WebSocket连接
  2. 不触发任何TTS播放
  3. 发送interrupt消息
  4. 观察服务器响应
- **预期结果**：
  - 服务器返回interrupt_complete消息
  - reason字段为"no_active_tts"或类似值
  - 不影响后续的正常交互

---

### 模块9：错误处理测试

#### TC-009-001 缺少必要字段_P0
- **测试场景**：发送缺少type字段的JSON消息
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送缺少type字段的JSON消息：
     ```json
     {
       "session_id": "xxx",
       "user_id": "xxx"
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回error消息
  - message字段描述错误原因
  - 不执行业务逻辑

#### TC-009-002 无效的消息类型_P0
- **测试场景**：发送不支持的type值
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送无效的type值：
     ```json
     {
       "type": "invalid_type",
       "session_id": "xxx"
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回error消息
  - message字段提示无效的消息类型
  - 连接保持正常

#### TC-009-003 无效的JSON格式_P0
- **测试场景**：发送格式错误的JSON数据
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送格式错误的JSON字符串：
     ```json
     { "type": "hello", "version": 1, "invalid"
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回error消息
  - message字段描述JSON解析错误
  - 连接可能被关闭或保持

#### TC-009-004 握手超时_P0
- **测试场景**：设备端在10秒内未发送hello消息
- **操作步骤**：
  1. 建立WebSocket连接
  2. 等待超过10秒不发送hello消息
  3. 观察连接状态
- **预期结果**：
  - 服务器主动断开连接
  - 触发OnDisconnected回调
  - 设备端应自动重连

#### TC-009-005 服务器响应超时_P1
- **测试场景**：服务器在10秒内未返回hello响应
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送hello消息
  3. 等待超过10秒未收到响应
  4. 观察设备端行为
- **预期结果**：
  - 设备端断开连接
  - 设备端自动重连
  - 重连后重新发送hello消息

#### TC-009-006 无效的音频参数_P1
- **测试场景**：发送不支持的音频参数
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送hello消息，包含无效的audio_params：
     ```json
     {
       "type": "hello",
       "version": 1,
       "audio_params": {
         "format": "invalid_format",
         "sample_rate": 99999,
         "channels": 10,
         "frame_duration": 999
       }
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回error消息
  - message字段描述参数错误
  - 服务器可能使用默认参数或拒绝连接

#### TC-009-007 无效的session_id_P1
- **测试场景**：使用不存在的session_id发送消息
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送listen消息，使用无效的session_id：
     ```json
     {
       "type": "listen",
       "session_id": "invalid_session_id",
       "state": "start"
     }
     ```
  3. 观察服务器响应
- **预期结果**：
  - 服务器返回error消息
  - message字段提示无效的会话ID
  - 连接保持正常

#### TC-009-008 无效的MCP方法_P1
- **测试场景**：服务器下发不支持的MCP方法
- **操作步骤**：
  1. 建立WebSocket连接并发送hello
  2. 模拟服务器下发无效的MCP消息：
     ```json
     {
       "type": "mcp",
       "session_id": "xxx",
       "payload": {
         "jsonrpc": "2.0",
         "method": "invalid_method",
         "params": {}
       }
     }
     ```
  3. 观察设备端行为
- **预期结果**：
  - 设备端忽略该消息
  - 或返回error消息给服务器
  - 不影响其他功能的正常运行

#### TC-009-009 网络中断恢复_P0
- **测试场景**：模拟网络中断后恢复
- **操作步骤**：
  1. 建立WebSocket连接并进行正常交互
  2. 模拟网络中断（断开网络连接）
  3. 等待设备端检测到连接断开
  4. 恢复网络连接
  5. 观察设备端重连行为
- **预期结果**：
  - 设备端检测到连接断开
  - 自动尝试重连
  - 重连成功后重新发送hello消息
  - 恢复正常交互

#### TC-009-010 服务器主动断开_P1
- **测试场景**：服务器发送goodbye消息后断开连接
- **操作步骤**：
  1. 建立WebSocket连接并进行交互
  2. 服务器发送goodbye消息：
     ```json
     {
       "type": "goodbye",
       "session_id": "xxx",
       "version": 1,
       "transport": "websocket",
       "talk_rounds": 5,
       "reason": "connection_closed"
     }
     ```
  3. 服务器主动断开连接
  4. 观察设备端行为
- **预期结果**：
  - 设备端收到goodbye消息
  - 设备端正常处理连接关闭
  - 设备端回到空闲状态
  - 设备端根据业务逻辑决定是否重连

---

### 模块10：性能与稳定性测试

#### TC-010-001 长时间连接稳定性_P0
- **测试场景**：保持WebSocket连接24小时
- **操作步骤**：
  1. 建立WebSocket连接
  2. 保持连接24小时不发送任何消息
  3. 定期检查连接状态
  4. 24小时后尝试发送消息
- **预期结果**：
  - 连接保持稳定，未自动断开
  - 24小时后可以正常发送和接收消息
  - 无内存泄漏或资源占用异常

#### TC-010-002 高频消息发送_P0
- **测试场景**：快速发送大量消息
- **操作步骤**：
  1. 建立WebSocket连接
  2. 在1秒内发送100条listen消息
  3. 观察服务器响应和处理情况
  4. 检查是否有消息丢失或错误
- **预期结果**：
  - 服务器正常处理所有消息
  - 无消息丢失
  - 无连接断开或错误
  - 响应时间在可接受范围内

#### TC-010-003 大音频数据传输_P0
- **测试场景**：传输长时间音频数据
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送10分钟的连续音频数据
  3. 观察服务器识别和响应情况
  4. 检查内存和CPU使用情况
- **预期结果**：
  - 音频数据正常传输
  - 服务器持续返回stt结果
  - 无内存泄漏
  - CPU使用率在合理范围内

#### TC-010-004 并发连接测试_P1
- **测试场景**：同时建立多个WebSocket连接
- **操作步骤**：
  1. 使用不同的device_id和user_id
  2. 同时建立10个WebSocket连接
  3. 每个连接进行正常交互
  4. 观察服务器性能和响应
- **预期结果**：
  - 所有连接正常建立
  - 每个连接独立工作，互不影响
  - 服务器性能在可接受范围内
  - 无连接冲突或数据混乱

#### TC-010-005 快速重连测试_P0
- **测试场景**：快速断开并重连
- **操作步骤**：
  1. 建立WebSocket连接
  2. 立即断开连接
  3. 立即重新连接
  4. 重复上述步骤100次
  5. 观察服务器和设备端状态
- **预期结果**：
  - 所有连接和重连操作成功
  - 服务器正常处理每次连接
  - 无资源泄漏或连接拒绝
  - 无性能下降

#### TC-010-006 内存泄漏测试_P1
- **测试场景**：长时间运行检测内存泄漏
- **操作步骤**：
  1. 建立WebSocket连接
  2. 进行1000次完整的对话交互
  3. 每次交互包括：listen → 音频 → stt → tts → 音频
  4. 记录初始内存使用量
  5. 记录完成后的内存使用量
  6. 对比内存增长情况
- **预期结果**：
  - 内存增长在合理范围内（<100MB）
  - 无明显的内存泄漏
  - 系统性能保持稳定

#### TC-010-007 响应时间测试_P1
- **测试场景**：测量各种操作的响应时间
- **操作步骤**：
  1. 建立WebSocket连接
  2. 测量hello消息的响应时间
  3. 测量listen消息的响应时间
  4. 测量音频数据到stt结果的响应时间
  5. 测量tts消息到音频数据的响应时间
  6. 测量interrupt消息的响应时间
  7. 每个测试重复100次取平均值
- **预期结果**：
  - hello响应时间 < 500ms
  - listen响应时间 < 100ms
  - stt响应时间 < 1000ms
  - tts响应时间 < 500ms
  - interrupt响应时间 < 200ms

#### TC-010-008 异常音频数据测试_P1
- **测试场景**：发送异常或损坏的音频数据
- **操作步骤**：
  1. 建立WebSocket连接
  2. 发送格式错误的音频数据
  3. 发送损坏的Opus编码数据
  4. 发送过大的音频帧
  5. 发送空音频帧
  6. 观察服务器响应
- **预期结果**：
  - 服务器返回error消息
  - message字段描述音频数据错误
  - 连接保持正常或优雅断开
  - 不影响后续的正常交互

#### TC-010-009 边界值测试_P1
- **测试场景**：测试各种参数的边界值
- **操作步骤**：
  1. 测试device_id和user_id的最大长度
  2. 测试audio_params的边界值：
     - sample_rate: 8000, 16000, 24000, 48000
     - channels: 1, 2
     - frame_duration: 20, 40, 60, 80, 100
  3. 测试session_id的最大长度
  4. 测试text字段的最大长度
- **预期结果**：
  - 边界值被正确处理
  - 超出边界时返回适当的错误
  - 无崩溃或异常行为

#### TC-010-010 压力测试_P0
- **测试场景**：高负载下的系统稳定性
- **操作步骤**：
  1. 建立50个并发WebSocket连接
  2. 每个连接每秒发送10条消息
  3. 持续运行30分钟
  4. 监控服务器性能指标：
     - CPU使用率
     - 内存使用量
     - 网络带宽
     - 响应时间
     - 错误率
- **预期结果**：
  - 系统保持稳定运行
  - CPU使用率 < 80%
  - 内存使用量在合理范围内
  - 响应时间在可接受范围内
  - 错误率 < 1%

---

## 4. 测试环境要求

### 4.1 硬件环境
- **测试服务器**：至少4核CPU，8GB内存
- **测试客户端**：普通PC或移动设备
- **网络**：稳定的网络连接，建议带宽 > 10Mbps

### 4.2 软件环境
- **WebSocket客户端库**：如Python的websocket-client
- **音频编解码库**：Opus
- **性能监控工具**：如top, htop, netstat
- **日志分析工具**：如ELK Stack或Splunk

### 4.3 测试数据
- **标准测试音频文件**：多种格式和采样率
- **异常音频文件**：损坏、格式错误等
- **测试用例配置文件**：包含各种测试场景的配置

## 5. 测试执行建议

### 5.1 测试顺序
1. 先执行P0级别的测试用例
2. 再执行P1级别的测试用例
3. 最后执行性能和稳定性测试

### 5.2 测试注意事项
1. 每个测试用例执行前确保环境干净
2. 记录详细的测试日志
3. 对失败的测试用例进行详细分析
4. 定期备份测试数据
5. 注意测试环境的隔离，避免相互影响

### 5.3 自动化建议
1. 使用自动化测试框架（如PyTest）
2. 编写测试脚本自动执行测试用例
3. 集成性能监控和日志收集
4. 生成测试报告和统计信息

## 6. 附录

### 6.1 测试用例优先级说明
- **P0**：核心功能，必须通过
- **P1**：重要功能，建议通过
- **P2**：次要功能，可选

### 6.2 测试覆盖率目标
- **功能覆盖率**：> 90%
- **代码覆盖率**：> 80%
- **场景覆盖率**：> 85%

### 6.3 测试报告模板
```
测试执行报告
==================
测试日期：YYYY-MM-DD
测试人员：XXX
测试环境：XXX

测试用例统计：
- 总用例数：XX
- 通过：XX
- 失败：XX
- 阻塞：XX
- 通过率：XX%

失败用例详情：
- TC-XXX-XXX：[失败原因]

风险评估：
- [高风险问题列表]

改进建议：
- [改进建议列表]
```

### 6.4 常见问题及解决方案
1. **连接失败**：检查网络连接和服务器状态
2. **音频无法播放**：检查音频参数和编解码器
3. **识别准确率低**：检查音频质量和采样率
4. **性能问题**：检查服务器负载和网络带宽
5. **内存泄漏**：使用内存分析工具定位问题

---

**文档版本**：1.0
**最后更新**：2026-01-09
**维护人员**：测试团队